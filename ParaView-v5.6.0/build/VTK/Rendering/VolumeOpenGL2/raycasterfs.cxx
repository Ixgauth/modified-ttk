#include "raycasterfs.h"

const char *raycasterfs =
"//VTK::System::Dec\n"
"\n"
"/*=========================================================================\n"
"\n"
"  Program:   Visualization Toolkit\n"
"  Module:    raycasterfs.glsl\n"
"\n"
"  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n"
"  All rights reserved.\n"
"  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n"
"\n"
"     This software is distributed WITHOUT ANY WARRANTY; without even\n"
"     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n"
"     PURPOSE.  See the above copyright notice for more information.\n"
"\n"
"=========================================================================*/\n"
"\n"
"//////////////////////////////////////////////////////////////////////////////\n"
"///\n"
"/// Inputs\n"
"///\n"
"//////////////////////////////////////////////////////////////////////////////\n"
"\n"
"/// 3D texture coordinates form vertex shader\n"
"in vec3 ip_textureCoords;\n"
"in vec3 ip_vertexPos;\n"
"\n"
"//////////////////////////////////////////////////////////////////////////////\n"
"///\n"
"/// Outputs\n"
"///\n"
"//////////////////////////////////////////////////////////////////////////////\n"
"\n"
"vec4 g_fragColor = vec4(0.0);\n"
"\n"
"//////////////////////////////////////////////////////////////////////////////\n"
"///\n"
"/// Uniforms, attributes, and globals\n"
"///\n"
"//////////////////////////////////////////////////////////////////////////////\n"
"vec3 g_dataPos;\n"
"vec3 g_terminatePos;\n"
"vec3 g_dirStep;\n"
"vec4 g_srcColor;\n"
"vec4 g_eyePosObj;\n"
"bool g_exit;\n"
"bool g_skip;\n"
"float g_currentT;\n"
"float g_terminatePointMax;\n"
"\n"
"//VTK::Output::Dec\n"
"\n"
"//VTK::Base::Dec\n"
"\n"
"//VTK::Termination::Dec\n"
"\n"
"//VTK::Cropping::Dec\n"
"\n"
"//VTK::Shading::Dec\n"
"\n"
"//VTK::BinaryMask::Dec\n"
"\n"
"//VTK::CompositeMask::Dec\n"
"\n"
"//VTK::GradientCache::Dec\n"
"\n"
"//VTK::Transfer2D::Dec\n"
"\n"
"//VTK::ComputeOpacity::Dec\n"
"\n"
"//VTK::ComputeGradient::Dec\n"
"\n"
"//VTK::ComputeGradientOpacity1D::Dec\n"
"\n"
"//VTK::ComputeLighting::Dec\n"
"\n"
"//VTK::ComputeColor::Dec\n"
"\n"
"//VTK::ComputeRayDirection::Dec\n"
"\n"
"//VTK::Picking::Dec\n"
"\n"
"//VTK::RenderToImage::Dec\n"
"\n"
"//VTK::DepthPeeling::Dec\n"
"\n"
"uniform float in_scale;\n"
"uniform float in_bias;\n"
"\n"
"//VTK::Clipping::Dec\n"
"\n"
"//////////////////////////////////////////////////////////////////////////////\n"
"///\n"
"/// Helper functions\n"
"///\n"
"//////////////////////////////////////////////////////////////////////////////\n"
"\n"
"/**\n"
" * Transform window coordinate to NDC.\n"
" */\n"
"vec4 WindowToNDC(const float xCoord, const float yCoord, const float zCoord)\n"
"{\n"
"  vec4 NDCCoord = vec4(0.0, 0.0, 0.0, 1.0);\n"
"\n"
"  NDCCoord.x = (xCoord - in_windowLowerLeftCorner.x) * 2.0 *\n"
"    in_inverseWindowSize.x - 1.0;\n"
"  NDCCoord.y = (yCoord - in_windowLowerLeftCorner.y) * 2.0 *\n"
"    in_inverseWindowSize.y - 1.0;\n"
"  NDCCoord.z = (2.0 * zCoord - (gl_DepthRange.near + gl_DepthRange.far)) /\n"
"    gl_DepthRange.diff;\n"
"\n"
"  return NDCCoord;\n"
"}\n"
"\n"
"/**\n"
" * Transform NDC coordinate to window coordinates.\n"
" */\n"
"vec4 NDCToWindow(const float xNDC, const float yNDC, const float zNDC)\n"
"{\n"
"  vec4 WinCoord = vec4(0.0, 0.0, 0.0, 1.0);\n"
"\n"
"  WinCoord.x = (xNDC + 1.f) / (2.f * in_inverseWindowSize.x) +\n"
"    in_windowLowerLeftCorner.x;\n"
"  WinCoord.y = (yNDC + 1.f) / (2.f * in_inverseWindowSize.y) +\n"
"    in_windowLowerLeftCorner.y;\n"
"  WinCoord.z = (zNDC * gl_DepthRange.diff +\n"
"    (gl_DepthRange.near + gl_DepthRange.far)) / 2.f;\n"
"\n"
"  return WinCoord;\n"
"}\n"
"\n"
"/**\n"
" * Clamps the texture coordinate vector @a pos to a new position in the set\n"
" * { start + i * step }, where i is an integer. If @a ceiling\n"
" * is true, the sample located further in the direction of @a step is used,\n"
" * otherwise the sample location closer to the eye is used.\n"
" */\n"
"vec3 ClampToSampleLocation(vec3 start, vec3 step, vec3 pos, bool ceiling)\n"
"{\n"
"  pos -= g_rayJitter;\n"
"\n"
"  vec3 offset = pos - start;\n"
"  float stepLength = length(step);\n"
"\n"
"  // Scalar projection of offset on step:\n"
"  float dist = dot(offset, step / stepLength);\n"
"  if (dist < 0.) // Don't move before the start position:\n"
"  {\n"
"    return start + g_rayJitter;\n"
"  }\n"
"\n"
"  // Number of steps\n"
"  float steps = dist / stepLength;\n"
"\n"
"  // If we're reeaaaaallly close, just round -- it's likely just numerical noise\n"
"  // and the value should be considered exact.\n"
"  if (abs(mod(steps, 1.)) > 1e-5)\n"
"  {\n"
"    if (ceiling)\n"
"    {\n"
"      steps = ceil(steps);\n"
"    }\n"
"    else\n"
"    {\n"
"      steps = floor(steps);\n"
"    }\n"
"  }\n"
"  else\n"
"  {\n"
"    steps = floor(steps + 0.5);\n"
"  }\n"
"\n"
"  return start + steps * step + g_rayJitter;\n"
"}\n"
"\n"
"//////////////////////////////////////////////////////////////////////////////\n"
"///\n"
"/// Ray-casting\n"
"///\n"
"//////////////////////////////////////////////////////////////////////////////\n"
"\n"
"/**\n"
" * Global initialization. This method should only be called once per shader\n"
" * invocation regardless of whether castRay() is called several times (e.g.\n"
" * vtkDualDepthPeelingPass). Any castRay() specific initialization should be\n"
" * placed within that function.\n"
" */\n"
"void initializeRayCast()\n"
"{\n"
"  /// Initialize g_fragColor (output) to 0\n"
"  g_fragColor = vec4(0.0);\n"
"  g_dirStep = vec3(0.0);\n"
"  g_srcColor = vec4(0.0);\n"
"  g_exit = false;\n"
"\n"
"  //VTK::Base::Init\n"
"\n"
"  //VTK::Terminate::Init\n"
"\n"
"  //VTK::Cropping::Init\n"
"\n"
"  //VTK::Clipping::Init\n"
"\n"
"  //VTK::RenderToImage::Init\n"
"\n"
"  //VTK::DepthPass::Init\n"
"}\n"
"\n"
"/**\n"
" * March along the ray direction sampling the volume texture.  This function\n"
" * takes a start and end point as arguments but it is up to the specific render\n"
" * pass implementation to use these values (e.g. vtkDualDepthPeelingPass). The\n"
" * mapper does not use these values by default, instead it uses the number of\n"
" * steps defined by g_terminatePointMax.\n"
" */\n"
"vec4 castRay(const float zStart, const float zEnd)\n"
"{\n"
"  //VTK::DepthPeeling::Ray::Init\n"
"\n"
"  //VTK::Clipping::Impl\n"
"\n"
"  //VTK::DepthPeeling::Ray::PathCheck\n"
"\n"
"  //VTK::Shading::Init\n"
"\n"
"  /// For all samples along the ray\n"
"  while (!g_exit)\n"
"  {\n"
"    //VTK::Base::Impl\n"
"\n"
"    //VTK::Cropping::Impl\n"
"\n"
"    //VTK::BinaryMask::Impl\n"
"\n"
"    //VTK::CompositeMask::Impl\n"
"\n"
"    //VTK::PreComputeGradients::Impl\n"
"\n"
"    //VTK::Shading::Impl\n"
"\n"
"    //VTK::RenderToImage::Impl\n"
"\n"
"    //VTK::DepthPass::Impl\n"
"\n"
"    /// Advance ray\n"
"    g_dataPos += g_dirStep;\n"
"\n"
"    //VTK::Terminate::Impl\n"
"  }\n"
"\n"
"  //VTK::Shading::Exit\n"
"\n"
"  return g_fragColor;\n"
"}\n"
"\n"
"/**\n"
" * Finalize specific modes and set output data.\n"
" */\n"
"void finalizeRayCast()\n"
"{\n"
"  //VTK::Base::Exit\n"
"\n"
"  //VTK::Terminate::Exit\n"
"\n"
"  //VTK::Cropping::Exit\n"
"\n"
"  //VTK::Clipping::Exit\n"
"\n"
"  //VTK::Picking::Exit\n"
"\n"
"  g_fragColor.r = g_fragColor.r * in_scale + in_bias * g_fragColor.a;\n"
"  g_fragColor.g = g_fragColor.g * in_scale + in_bias * g_fragColor.a;\n"
"  g_fragColor.b = g_fragColor.b * in_scale + in_bias * g_fragColor.a;\n"
"  gl_FragData[0] = g_fragColor;\n"
"\n"
"  //VTK::RenderToImage::Exit\n"
"\n"
"  //VTK::DepthPass::Exit\n"
"}\n"
"\n"
"//////////////////////////////////////////////////////////////////////////////\n"
"///\n"
"/// Main\n"
"///\n"
"//////////////////////////////////////////////////////////////////////////////\n"
"void main()\n"
"{\n"
"  //VTK::CallWorker::Impl\n"
"}\n"
"";
