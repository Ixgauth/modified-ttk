// python wrapper for vtkTrimmedExtrusionFilter
//
#define VTK_WRAPPING_CXX
#define VTK_STREAMS_FWD_ONLY
#include "vtkPythonArgs.h"
#include "vtkPythonOverload.h"
#include "vtkConfigure.h"
#include <cstddef>
#include <sstream>
#include "vtkVariant.h"
#include "vtkIndent.h"
#include "vtkTrimmedExtrusionFilter.h"

extern "C" { VTK_ABI_EXPORT void PyVTKAddFile_vtkTrimmedExtrusionFilter(PyObject *); }
extern "C" { VTK_ABI_EXPORT PyObject *PyvtkTrimmedExtrusionFilter_ClassNew(); }

#ifndef DECLARED_PyvtkPolyDataAlgorithm_ClassNew
extern "C" { PyObject *PyvtkPolyDataAlgorithm_ClassNew(); }
#define DECLARED_PyvtkPolyDataAlgorithm_ClassNew
#endif

static const char *PyvtkTrimmedExtrusionFilter_Doc =
  "vtkTrimmedExtrusionFilter - extrude polygonal data trimmed by a\nsecond input surface\n\n"
  "Superclass: vtkPolyDataAlgorithm\n\n"
  "vtkTrimmedExtrusionFilter is a modeling filter. It takes polygonal\n"
  "data as input and generates polygonal data on output. The input\n"
  "dataset is swept along a specified direction forming a \"skirt\" from\n"
  "the boundary edges 2D primitives (i.e., edges used by only one\n"
  "polygon); and/or from vertices and lines. The extent of the sweeping\n"
  "is limited by a second input: defined where the sweep intersects a\n"
  "user-specified surface.\n\n"
  "Capping of the extrusion can be enabled. In this case the input,\n"
  "generating primitive is copied inplace as well as to the end of the\n"
  "extrusion skirt. (See warnings below on what happens if the\n"
  "intersecting sweep does not intersect, or partially intersects the\n"
  "trim surface.)\n\n"
  "Note that this filter operates in two fundamentally different modes\n"
  "based on the extrusion strategy. If the strategy is BOUNDARY_EDGES,\n"
  "then only the boundary edges of the input's 2D primitives are\n"
  "extruded (verts and lines are extruded to generate lines and quads).\n"
  "However, if the extrusions strategy is ALL_EDGES, then every edge of\n"
  "the 2D primitives is used to sweep out a quadrilateral polygon (again\n"
  "verts and lines are swept to produce lines and quads).\n\n"
  "@warning\n"
  "The extrusion direction is assumed to define an infinite line. The\n"
  "intersection with the trim surface is along a ray from the - to +\n"
  "direction, however only the first intersection is taken.\n\n"
  "@warning\n"
  "Some polygonal objects have no free edges (e.g., sphere). When swept,\n"
  "this will result in two separate surfaces if capping is on and\n"
  "BOUNDARY_EDGES enabled, or no surface if capping is off and\n"
  "BOUNDARY_EDGES is enabled.\n\n"
  "@warning\n"
  "If all the extrusion lines emanating from an extruding primitive do\n"
  "not intersect the trim surface, then no output for that primitive\n"
  "will be generated. In extreme cases, it it possible that no output\n"
  "whatsoever will be generated by the filter.\n\n"
  "@warning\n"
  "This class has been threaded with vtkSMPTools. Using TBB or other\n"
  "non-sequential type (set in the CMake variable\n"
  "VTK_SMP_IMPLEMENTATION_TYPE) may improve performance significantly.\n\n"
  "@sa\n"
  "vtkLinearExtrusionFilter vtkRotationalExtrusionFilter\n\n";

static PyTypeObject PyvtkTrimmedExtrusionFilter_ExtrusionStrategy_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "vtkFiltersModelingPython.vtkTrimmedExtrusionFilter.ExtrusionStrategy", // tp_name
  sizeof(PyIntObject), // tp_basicsize
  0, // tp_itemsize
  nullptr, // tp_dealloc
  nullptr, // tp_print
  nullptr, // tp_getattr
  nullptr, // tp_setattr
  nullptr, // tp_compare
  nullptr, // tp_repr
  nullptr, // tp_as_number
  nullptr, // tp_as_sequence
  nullptr, // tp_as_mapping
  nullptr, // tp_hash
  nullptr, // tp_call
  nullptr, // tp_str
  nullptr, // tp_getattro
  nullptr, // tp_setattro
  nullptr, // tp_as_buffer
  Py_TPFLAGS_DEFAULT, // tp_flags
  nullptr, // tp_doc
  nullptr, // tp_traverse
  nullptr, // tp_clear
  nullptr, // tp_richcompare
  0, // tp_weaklistoffset
  nullptr, // tp_iter
  nullptr, // tp_iternext
  nullptr, // tp_methods
  nullptr, // tp_members
  nullptr, // tp_getset
  &PyInt_Type, // tp_base
  nullptr, // tp_dict
  nullptr, // tp_descr_get
  nullptr, // tp_descr_set
  0, // tp_dictoffset
  nullptr, // tp_init
  nullptr, // tp_alloc
  nullptr, // tp_new
  PyObject_Del, // tp_free
  nullptr, // tp_is_gc
  nullptr, // tp_bases
  nullptr, // tp_mro
  nullptr, // tp_cache
  nullptr, // tp_subclasses
  nullptr, // tp_weaklist
  VTK_WRAP_PYTHON_SUPPRESS_UNINITIALIZED
};

PyObject *PyvtkTrimmedExtrusionFilter_ExtrusionStrategy_FromEnum(int val)
{
#ifdef VTK_PY3K
  PyObject *args = Py_BuildValue("(i)", val);
  PyObject *obj = PyLong_Type.tp_new(&PyvtkTrimmedExtrusionFilter_ExtrusionStrategy_Type, args, nullptr);
  Py_DECREF(args);
  return obj;
#else
  PyIntObject *self = PyObject_New(PyIntObject,
    &PyvtkTrimmedExtrusionFilter_ExtrusionStrategy_Type);
  self->ob_ival = val;
  return (PyObject *)self;
#endif
}

static PyTypeObject PyvtkTrimmedExtrusionFilter_CappingStrategy_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "vtkFiltersModelingPython.vtkTrimmedExtrusionFilter.CappingStrategy", // tp_name
  sizeof(PyIntObject), // tp_basicsize
  0, // tp_itemsize
  nullptr, // tp_dealloc
  nullptr, // tp_print
  nullptr, // tp_getattr
  nullptr, // tp_setattr
  nullptr, // tp_compare
  nullptr, // tp_repr
  nullptr, // tp_as_number
  nullptr, // tp_as_sequence
  nullptr, // tp_as_mapping
  nullptr, // tp_hash
  nullptr, // tp_call
  nullptr, // tp_str
  nullptr, // tp_getattro
  nullptr, // tp_setattro
  nullptr, // tp_as_buffer
  Py_TPFLAGS_DEFAULT, // tp_flags
  nullptr, // tp_doc
  nullptr, // tp_traverse
  nullptr, // tp_clear
  nullptr, // tp_richcompare
  0, // tp_weaklistoffset
  nullptr, // tp_iter
  nullptr, // tp_iternext
  nullptr, // tp_methods
  nullptr, // tp_members
  nullptr, // tp_getset
  &PyInt_Type, // tp_base
  nullptr, // tp_dict
  nullptr, // tp_descr_get
  nullptr, // tp_descr_set
  0, // tp_dictoffset
  nullptr, // tp_init
  nullptr, // tp_alloc
  nullptr, // tp_new
  PyObject_Del, // tp_free
  nullptr, // tp_is_gc
  nullptr, // tp_bases
  nullptr, // tp_mro
  nullptr, // tp_cache
  nullptr, // tp_subclasses
  nullptr, // tp_weaklist
  VTK_WRAP_PYTHON_SUPPRESS_UNINITIALIZED
};

PyObject *PyvtkTrimmedExtrusionFilter_CappingStrategy_FromEnum(int val)
{
#ifdef VTK_PY3K
  PyObject *args = Py_BuildValue("(i)", val);
  PyObject *obj = PyLong_Type.tp_new(&PyvtkTrimmedExtrusionFilter_CappingStrategy_Type, args, nullptr);
  Py_DECREF(args);
  return obj;
#else
  PyIntObject *self = PyObject_New(PyIntObject,
    &PyvtkTrimmedExtrusionFilter_CappingStrategy_Type);
  self->ob_ival = val;
  return (PyObject *)self;
#endif
}


static PyObject *
PyvtkTrimmedExtrusionFilter_IsTypeOf(PyObject *, PyObject *args)
{
  vtkPythonArgs ap(args, "IsTypeOf");

  const char *temp0 = nullptr;
  PyObject *result = nullptr;

  if (ap.CheckArgCount(1) &&
      ap.GetValue(temp0))
  {
    int tempr = vtkTrimmedExtrusionFilter::IsTypeOf(temp0);

    if (!ap.ErrorOccurred())
    {
      result = ap.BuildValue(tempr);
    }
  }

  return result;
}


static PyObject *
PyvtkTrimmedExtrusionFilter_IsA(PyObject *self, PyObject *args)
{
  vtkPythonArgs ap(self, args, "IsA");
  vtkObjectBase *vp = ap.GetSelfPointer(self, args);
  vtkTrimmedExtrusionFilter *op = static_cast<vtkTrimmedExtrusionFilter *>(vp);

  const char *temp0 = nullptr;
  PyObject *result = nullptr;

  if (op && ap.CheckArgCount(1) &&
      ap.GetValue(temp0))
  {
    int tempr = (ap.IsBound() ?
      op->IsA(temp0) :
      op->vtkTrimmedExtrusionFilter::IsA(temp0));

    if (!ap.ErrorOccurred())
    {
      result = ap.BuildValue(tempr);
    }
  }

  return result;
}


static PyObject *
PyvtkTrimmedExtrusionFilter_SafeDownCast(PyObject *, PyObject *args)
{
  vtkPythonArgs ap(args, "SafeDownCast");

  vtkObjectBase *temp0 = nullptr;
  PyObject *result = nullptr;

  if (ap.CheckArgCount(1) &&
      ap.GetVTKObject(temp0, "vtkObjectBase"))
  {
    vtkTrimmedExtrusionFilter *tempr = vtkTrimmedExtrusionFilter::SafeDownCast(temp0);

    if (!ap.ErrorOccurred())
    {
      result = ap.BuildVTKObject(tempr);
    }
  }

  return result;
}


static PyObject *
PyvtkTrimmedExtrusionFilter_NewInstance(PyObject *self, PyObject *args)
{
  vtkPythonArgs ap(self, args, "NewInstance");
  vtkObjectBase *vp = ap.GetSelfPointer(self, args);
  vtkTrimmedExtrusionFilter *op = static_cast<vtkTrimmedExtrusionFilter *>(vp);

  PyObject *result = nullptr;

  if (op && ap.CheckArgCount(0))
  {
    vtkTrimmedExtrusionFilter *tempr = (ap.IsBound() ?
      op->NewInstance() :
      op->vtkTrimmedExtrusionFilter::NewInstance());

    if (!ap.ErrorOccurred())
    {
      result = ap.BuildVTKObject(tempr);
      if (result && PyVTKObject_Check(result))
      {
        PyVTKObject_GetObject(result)->UnRegister(0);
        PyVTKObject_SetFlag(result, VTK_PYTHON_IGNORE_UNREGISTER, 1);
      }
    }
  }

  return result;
}


static PyObject *
PyvtkTrimmedExtrusionFilter_SetExtrusionDirection_s1(PyObject *self, PyObject *args)
{
  vtkPythonArgs ap(self, args, "SetExtrusionDirection");
  vtkObjectBase *vp = ap.GetSelfPointer(self, args);
  vtkTrimmedExtrusionFilter *op = static_cast<vtkTrimmedExtrusionFilter *>(vp);

  double temp0;
  double temp1;
  double temp2;
  PyObject *result = nullptr;

  if (op && ap.CheckArgCount(3) &&
      ap.GetValue(temp0) &&
      ap.GetValue(temp1) &&
      ap.GetValue(temp2))
  {
    if (ap.IsBound())
    {
      op->SetExtrusionDirection(temp0, temp1, temp2);
    }
    else
    {
      op->vtkTrimmedExtrusionFilter::SetExtrusionDirection(temp0, temp1, temp2);
    }

    if (!ap.ErrorOccurred())
    {
      result = ap.BuildNone();
    }
  }

  return result;
}

static PyObject *
PyvtkTrimmedExtrusionFilter_SetExtrusionDirection_s2(PyObject *self, PyObject *args)
{
  vtkPythonArgs ap(self, args, "SetExtrusionDirection");
  vtkObjectBase *vp = ap.GetSelfPointer(self, args);
  vtkTrimmedExtrusionFilter *op = static_cast<vtkTrimmedExtrusionFilter *>(vp);

  const size_t size0 = 3;
  double temp0[3];
  PyObject *result = nullptr;

  if (op && ap.CheckArgCount(1) &&
      ap.GetArray(temp0, size0))
  {
    if (ap.IsBound())
    {
      op->SetExtrusionDirection(temp0);
    }
    else
    {
      op->vtkTrimmedExtrusionFilter::SetExtrusionDirection(temp0);
    }

    if (!ap.ErrorOccurred())
    {
      result = ap.BuildNone();
    }
  }

  return result;
}

static PyObject *
PyvtkTrimmedExtrusionFilter_SetExtrusionDirection(PyObject *self, PyObject *args)
{
  int nargs = vtkPythonArgs::GetArgCount(self, args);

  switch(nargs)
  {
    case 3:
      return PyvtkTrimmedExtrusionFilter_SetExtrusionDirection_s1(self, args);
    case 1:
      return PyvtkTrimmedExtrusionFilter_SetExtrusionDirection_s2(self, args);
  }

  vtkPythonArgs::ArgCountError(nargs, "SetExtrusionDirection");
  return nullptr;
}



static PyObject *
PyvtkTrimmedExtrusionFilter_GetExtrusionDirection(PyObject *self, PyObject *args)
{
  vtkPythonArgs ap(self, args, "GetExtrusionDirection");
  vtkObjectBase *vp = ap.GetSelfPointer(self, args);
  vtkTrimmedExtrusionFilter *op = static_cast<vtkTrimmedExtrusionFilter *>(vp);

  size_t sizer = 3;
  PyObject *result = nullptr;

  if (op && ap.CheckArgCount(0))
  {
    double *tempr = (ap.IsBound() ?
      op->GetExtrusionDirection() :
      op->vtkTrimmedExtrusionFilter::GetExtrusionDirection());

    if (!ap.ErrorOccurred())
    {
      result = ap.BuildTuple(tempr, sizer);
    }
  }

  return result;
}


static PyObject *
PyvtkTrimmedExtrusionFilter_SetTrimSurfaceData(PyObject *self, PyObject *args)
{
  vtkPythonArgs ap(self, args, "SetTrimSurfaceData");
  vtkObjectBase *vp = ap.GetSelfPointer(self, args);
  vtkTrimmedExtrusionFilter *op = static_cast<vtkTrimmedExtrusionFilter *>(vp);

  vtkPolyData *temp0 = nullptr;
  PyObject *result = nullptr;

  if (op && ap.CheckArgCount(1) &&
      ap.GetVTKObject(temp0, "vtkPolyData"))
  {
    if (ap.IsBound())
    {
      op->SetTrimSurfaceData(temp0);
    }
    else
    {
      op->vtkTrimmedExtrusionFilter::SetTrimSurfaceData(temp0);
    }

    if (!ap.ErrorOccurred())
    {
      result = ap.BuildNone();
    }
  }

  return result;
}


static PyObject *
PyvtkTrimmedExtrusionFilter_SetTrimSurfaceConnection(PyObject *self, PyObject *args)
{
  vtkPythonArgs ap(self, args, "SetTrimSurfaceConnection");
  vtkObjectBase *vp = ap.GetSelfPointer(self, args);
  vtkTrimmedExtrusionFilter *op = static_cast<vtkTrimmedExtrusionFilter *>(vp);

  vtkAlgorithmOutput *temp0 = nullptr;
  PyObject *result = nullptr;

  if (op && ap.CheckArgCount(1) &&
      ap.GetVTKObject(temp0, "vtkAlgorithmOutput"))
  {
    if (ap.IsBound())
    {
      op->SetTrimSurfaceConnection(temp0);
    }
    else
    {
      op->vtkTrimmedExtrusionFilter::SetTrimSurfaceConnection(temp0);
    }

    if (!ap.ErrorOccurred())
    {
      result = ap.BuildNone();
    }
  }

  return result;
}


static PyObject *
PyvtkTrimmedExtrusionFilter_GetTrimSurface_s1(PyObject *self, PyObject *args)
{
  vtkPythonArgs ap(self, args, "GetTrimSurface");
  vtkObjectBase *vp = ap.GetSelfPointer(self, args);
  vtkTrimmedExtrusionFilter *op = static_cast<vtkTrimmedExtrusionFilter *>(vp);

  PyObject *result = nullptr;

  if (op && ap.CheckArgCount(0))
  {
    vtkPolyData *tempr = (ap.IsBound() ?
      op->GetTrimSurface() :
      op->vtkTrimmedExtrusionFilter::GetTrimSurface());

    if (!ap.ErrorOccurred())
    {
      result = ap.BuildVTKObject(tempr);
    }
  }

  return result;
}

static PyObject *
PyvtkTrimmedExtrusionFilter_GetTrimSurface_s2(PyObject *self, PyObject *args)
{
  vtkPythonArgs ap(self, args, "GetTrimSurface");
  vtkObjectBase *vp = ap.GetSelfPointer(self, args);
  vtkTrimmedExtrusionFilter *op = static_cast<vtkTrimmedExtrusionFilter *>(vp);

  vtkInformationVector *temp0 = nullptr;
  PyObject *result = nullptr;

  if (op && ap.CheckArgCount(1) &&
      ap.GetVTKObject(temp0, "vtkInformationVector"))
  {
    vtkPolyData *tempr = (ap.IsBound() ?
      op->GetTrimSurface(temp0) :
      op->vtkTrimmedExtrusionFilter::GetTrimSurface(temp0));

    if (!ap.ErrorOccurred())
    {
      result = ap.BuildVTKObject(tempr);
    }
  }

  return result;
}

static PyObject *
PyvtkTrimmedExtrusionFilter_GetTrimSurface(PyObject *self, PyObject *args)
{
  int nargs = vtkPythonArgs::GetArgCount(self, args);

  switch(nargs)
  {
    case 0:
      return PyvtkTrimmedExtrusionFilter_GetTrimSurface_s1(self, args);
    case 1:
      return PyvtkTrimmedExtrusionFilter_GetTrimSurface_s2(self, args);
  }

  vtkPythonArgs::ArgCountError(nargs, "GetTrimSurface");
  return nullptr;
}



static PyObject *
PyvtkTrimmedExtrusionFilter_SetCapping(PyObject *self, PyObject *args)
{
  vtkPythonArgs ap(self, args, "SetCapping");
  vtkObjectBase *vp = ap.GetSelfPointer(self, args);
  vtkTrimmedExtrusionFilter *op = static_cast<vtkTrimmedExtrusionFilter *>(vp);

  int temp0;
  PyObject *result = nullptr;

  if (op && ap.CheckArgCount(1) &&
      ap.GetValue(temp0))
  {
    if (ap.IsBound())
    {
      op->SetCapping(temp0);
    }
    else
    {
      op->vtkTrimmedExtrusionFilter::SetCapping(temp0);
    }

    if (!ap.ErrorOccurred())
    {
      result = ap.BuildNone();
    }
  }

  return result;
}


static PyObject *
PyvtkTrimmedExtrusionFilter_GetCapping(PyObject *self, PyObject *args)
{
  vtkPythonArgs ap(self, args, "GetCapping");
  vtkObjectBase *vp = ap.GetSelfPointer(self, args);
  vtkTrimmedExtrusionFilter *op = static_cast<vtkTrimmedExtrusionFilter *>(vp);

  PyObject *result = nullptr;

  if (op && ap.CheckArgCount(0))
  {
    int tempr = (ap.IsBound() ?
      op->GetCapping() :
      op->vtkTrimmedExtrusionFilter::GetCapping());

    if (!ap.ErrorOccurred())
    {
      result = ap.BuildValue(tempr);
    }
  }

  return result;
}


static PyObject *
PyvtkTrimmedExtrusionFilter_CappingOn(PyObject *self, PyObject *args)
{
  vtkPythonArgs ap(self, args, "CappingOn");
  vtkObjectBase *vp = ap.GetSelfPointer(self, args);
  vtkTrimmedExtrusionFilter *op = static_cast<vtkTrimmedExtrusionFilter *>(vp);

  PyObject *result = nullptr;

  if (op && ap.CheckArgCount(0))
  {
    if (ap.IsBound())
    {
      op->CappingOn();
    }
    else
    {
      op->vtkTrimmedExtrusionFilter::CappingOn();
    }

    if (!ap.ErrorOccurred())
    {
      result = ap.BuildNone();
    }
  }

  return result;
}


static PyObject *
PyvtkTrimmedExtrusionFilter_CappingOff(PyObject *self, PyObject *args)
{
  vtkPythonArgs ap(self, args, "CappingOff");
  vtkObjectBase *vp = ap.GetSelfPointer(self, args);
  vtkTrimmedExtrusionFilter *op = static_cast<vtkTrimmedExtrusionFilter *>(vp);

  PyObject *result = nullptr;

  if (op && ap.CheckArgCount(0))
  {
    if (ap.IsBound())
    {
      op->CappingOff();
    }
    else
    {
      op->vtkTrimmedExtrusionFilter::CappingOff();
    }

    if (!ap.ErrorOccurred())
    {
      result = ap.BuildNone();
    }
  }

  return result;
}


static PyObject *
PyvtkTrimmedExtrusionFilter_SetExtrusionStrategy(PyObject *self, PyObject *args)
{
  vtkPythonArgs ap(self, args, "SetExtrusionStrategy");
  vtkObjectBase *vp = ap.GetSelfPointer(self, args);
  vtkTrimmedExtrusionFilter *op = static_cast<vtkTrimmedExtrusionFilter *>(vp);

  int temp0;
  PyObject *result = nullptr;

  if (op && ap.CheckArgCount(1) &&
      ap.GetValue(temp0))
  {
    if (ap.IsBound())
    {
      op->SetExtrusionStrategy(temp0);
    }
    else
    {
      op->vtkTrimmedExtrusionFilter::SetExtrusionStrategy(temp0);
    }

    if (!ap.ErrorOccurred())
    {
      result = ap.BuildNone();
    }
  }

  return result;
}


static PyObject *
PyvtkTrimmedExtrusionFilter_GetExtrusionStrategy(PyObject *self, PyObject *args)
{
  vtkPythonArgs ap(self, args, "GetExtrusionStrategy");
  vtkObjectBase *vp = ap.GetSelfPointer(self, args);
  vtkTrimmedExtrusionFilter *op = static_cast<vtkTrimmedExtrusionFilter *>(vp);

  PyObject *result = nullptr;

  if (op && ap.CheckArgCount(0))
  {
    int tempr = (ap.IsBound() ?
      op->GetExtrusionStrategy() :
      op->vtkTrimmedExtrusionFilter::GetExtrusionStrategy());

    if (!ap.ErrorOccurred())
    {
      result = ap.BuildValue(tempr);
    }
  }

  return result;
}


static PyObject *
PyvtkTrimmedExtrusionFilter_SetExtrusionStrategyToBoundaryEdges(PyObject *self, PyObject *args)
{
  vtkPythonArgs ap(self, args, "SetExtrusionStrategyToBoundaryEdges");
  vtkObjectBase *vp = ap.GetSelfPointer(self, args);
  vtkTrimmedExtrusionFilter *op = static_cast<vtkTrimmedExtrusionFilter *>(vp);

  PyObject *result = nullptr;

  if (op && ap.CheckArgCount(0))
  {
    if (ap.IsBound())
    {
      op->SetExtrusionStrategyToBoundaryEdges();
    }
    else
    {
      op->vtkTrimmedExtrusionFilter::SetExtrusionStrategyToBoundaryEdges();
    }

    if (!ap.ErrorOccurred())
    {
      result = ap.BuildNone();
    }
  }

  return result;
}


static PyObject *
PyvtkTrimmedExtrusionFilter_SetExtrusionStrategyToAllEdges(PyObject *self, PyObject *args)
{
  vtkPythonArgs ap(self, args, "SetExtrusionStrategyToAllEdges");
  vtkObjectBase *vp = ap.GetSelfPointer(self, args);
  vtkTrimmedExtrusionFilter *op = static_cast<vtkTrimmedExtrusionFilter *>(vp);

  PyObject *result = nullptr;

  if (op && ap.CheckArgCount(0))
  {
    if (ap.IsBound())
    {
      op->SetExtrusionStrategyToAllEdges();
    }
    else
    {
      op->vtkTrimmedExtrusionFilter::SetExtrusionStrategyToAllEdges();
    }

    if (!ap.ErrorOccurred())
    {
      result = ap.BuildNone();
    }
  }

  return result;
}


static PyObject *
PyvtkTrimmedExtrusionFilter_SetCappingStrategy(PyObject *self, PyObject *args)
{
  vtkPythonArgs ap(self, args, "SetCappingStrategy");
  vtkObjectBase *vp = ap.GetSelfPointer(self, args);
  vtkTrimmedExtrusionFilter *op = static_cast<vtkTrimmedExtrusionFilter *>(vp);

  int temp0;
  PyObject *result = nullptr;

  if (op && ap.CheckArgCount(1) &&
      ap.GetValue(temp0))
  {
    if (ap.IsBound())
    {
      op->SetCappingStrategy(temp0);
    }
    else
    {
      op->vtkTrimmedExtrusionFilter::SetCappingStrategy(temp0);
    }

    if (!ap.ErrorOccurred())
    {
      result = ap.BuildNone();
    }
  }

  return result;
}


static PyObject *
PyvtkTrimmedExtrusionFilter_GetCappingStrategy(PyObject *self, PyObject *args)
{
  vtkPythonArgs ap(self, args, "GetCappingStrategy");
  vtkObjectBase *vp = ap.GetSelfPointer(self, args);
  vtkTrimmedExtrusionFilter *op = static_cast<vtkTrimmedExtrusionFilter *>(vp);

  PyObject *result = nullptr;

  if (op && ap.CheckArgCount(0))
  {
    int tempr = (ap.IsBound() ?
      op->GetCappingStrategy() :
      op->vtkTrimmedExtrusionFilter::GetCappingStrategy());

    if (!ap.ErrorOccurred())
    {
      result = ap.BuildValue(tempr);
    }
  }

  return result;
}


static PyObject *
PyvtkTrimmedExtrusionFilter_SetCappingStrategyToIntersection(PyObject *self, PyObject *args)
{
  vtkPythonArgs ap(self, args, "SetCappingStrategyToIntersection");
  vtkObjectBase *vp = ap.GetSelfPointer(self, args);
  vtkTrimmedExtrusionFilter *op = static_cast<vtkTrimmedExtrusionFilter *>(vp);

  PyObject *result = nullptr;

  if (op && ap.CheckArgCount(0))
  {
    if (ap.IsBound())
    {
      op->SetCappingStrategyToIntersection();
    }
    else
    {
      op->vtkTrimmedExtrusionFilter::SetCappingStrategyToIntersection();
    }

    if (!ap.ErrorOccurred())
    {
      result = ap.BuildNone();
    }
  }

  return result;
}


static PyObject *
PyvtkTrimmedExtrusionFilter_SetCappingStrategyToMinimumDistance(PyObject *self, PyObject *args)
{
  vtkPythonArgs ap(self, args, "SetCappingStrategyToMinimumDistance");
  vtkObjectBase *vp = ap.GetSelfPointer(self, args);
  vtkTrimmedExtrusionFilter *op = static_cast<vtkTrimmedExtrusionFilter *>(vp);

  PyObject *result = nullptr;

  if (op && ap.CheckArgCount(0))
  {
    if (ap.IsBound())
    {
      op->SetCappingStrategyToMinimumDistance();
    }
    else
    {
      op->vtkTrimmedExtrusionFilter::SetCappingStrategyToMinimumDistance();
    }

    if (!ap.ErrorOccurred())
    {
      result = ap.BuildNone();
    }
  }

  return result;
}


static PyObject *
PyvtkTrimmedExtrusionFilter_SetCappingStrategyToMaximumDistance(PyObject *self, PyObject *args)
{
  vtkPythonArgs ap(self, args, "SetCappingStrategyToMaximumDistance");
  vtkObjectBase *vp = ap.GetSelfPointer(self, args);
  vtkTrimmedExtrusionFilter *op = static_cast<vtkTrimmedExtrusionFilter *>(vp);

  PyObject *result = nullptr;

  if (op && ap.CheckArgCount(0))
  {
    if (ap.IsBound())
    {
      op->SetCappingStrategyToMaximumDistance();
    }
    else
    {
      op->vtkTrimmedExtrusionFilter::SetCappingStrategyToMaximumDistance();
    }

    if (!ap.ErrorOccurred())
    {
      result = ap.BuildNone();
    }
  }

  return result;
}


static PyObject *
PyvtkTrimmedExtrusionFilter_SetCappingStrategyToAverageDistance(PyObject *self, PyObject *args)
{
  vtkPythonArgs ap(self, args, "SetCappingStrategyToAverageDistance");
  vtkObjectBase *vp = ap.GetSelfPointer(self, args);
  vtkTrimmedExtrusionFilter *op = static_cast<vtkTrimmedExtrusionFilter *>(vp);

  PyObject *result = nullptr;

  if (op && ap.CheckArgCount(0))
  {
    if (ap.IsBound())
    {
      op->SetCappingStrategyToAverageDistance();
    }
    else
    {
      op->vtkTrimmedExtrusionFilter::SetCappingStrategyToAverageDistance();
    }

    if (!ap.ErrorOccurred())
    {
      result = ap.BuildNone();
    }
  }

  return result;
}


static PyObject *
PyvtkTrimmedExtrusionFilter_SetLocator(PyObject *self, PyObject *args)
{
  vtkPythonArgs ap(self, args, "SetLocator");
  vtkObjectBase *vp = ap.GetSelfPointer(self, args);
  vtkTrimmedExtrusionFilter *op = static_cast<vtkTrimmedExtrusionFilter *>(vp);

  vtkAbstractCellLocator *temp0 = nullptr;
  PyObject *result = nullptr;

  if (op && ap.CheckArgCount(1) &&
      ap.GetVTKObject(temp0, "vtkAbstractCellLocator"))
  {
    if (ap.IsBound())
    {
      op->SetLocator(temp0);
    }
    else
    {
      op->vtkTrimmedExtrusionFilter::SetLocator(temp0);
    }

    if (!ap.ErrorOccurred())
    {
      result = ap.BuildNone();
    }
  }

  return result;
}


static PyObject *
PyvtkTrimmedExtrusionFilter_GetLocator(PyObject *self, PyObject *args)
{
  vtkPythonArgs ap(self, args, "GetLocator");
  vtkObjectBase *vp = ap.GetSelfPointer(self, args);
  vtkTrimmedExtrusionFilter *op = static_cast<vtkTrimmedExtrusionFilter *>(vp);

  PyObject *result = nullptr;

  if (op && ap.CheckArgCount(0))
  {
    vtkAbstractCellLocator *tempr = (ap.IsBound() ?
      op->GetLocator() :
      op->vtkTrimmedExtrusionFilter::GetLocator());

    if (!ap.ErrorOccurred())
    {
      result = ap.BuildVTKObject(tempr);
    }
  }

  return result;
}

static PyMethodDef PyvtkTrimmedExtrusionFilter_Methods[] = {
  {"IsTypeOf", PyvtkTrimmedExtrusionFilter_IsTypeOf, METH_VARARGS,
   "V.IsTypeOf(string) -> int\nC++: static vtkTypeBool IsTypeOf(const char *type)\n\nReturn 1 if this class type is the same type of (or a subclass\nof) the named class. Returns 0 otherwise. This method works in\ncombination with vtkTypeMacro found in vtkSetGet.h.\n"},
  {"IsA", PyvtkTrimmedExtrusionFilter_IsA, METH_VARARGS,
   "V.IsA(string) -> int\nC++: vtkTypeBool IsA(const char *type) override;\n\nReturn 1 if this class is the same type of (or a subclass of) the\nnamed class. Returns 0 otherwise. This method works in\ncombination with vtkTypeMacro found in vtkSetGet.h.\n"},
  {"SafeDownCast", PyvtkTrimmedExtrusionFilter_SafeDownCast, METH_VARARGS,
   "V.SafeDownCast(vtkObjectBase) -> vtkTrimmedExtrusionFilter\nC++: static vtkTrimmedExtrusionFilter *SafeDownCast(\n    vtkObjectBase *o)\n\n"},
  {"NewInstance", PyvtkTrimmedExtrusionFilter_NewInstance, METH_VARARGS,
   "V.NewInstance() -> vtkTrimmedExtrusionFilter\nC++: vtkTrimmedExtrusionFilter *NewInstance()\n\n"},
  {"SetExtrusionDirection", PyvtkTrimmedExtrusionFilter_SetExtrusionDirection, METH_VARARGS,
   "V.SetExtrusionDirection(float, float, float)\nC++: void SetExtrusionDirection(double, double, double)\nV.SetExtrusionDirection((float, float, float))\nC++: void SetExtrusionDirection(double a[3])\n\n"},
  {"GetExtrusionDirection", PyvtkTrimmedExtrusionFilter_GetExtrusionDirection, METH_VARARGS,
   "V.GetExtrusionDirection() -> (float, float, float)\nC++: double *GetExtrusionDirection()\n\nSet/Get the extrusion direction.\n"},
  {"SetTrimSurfaceData", PyvtkTrimmedExtrusionFilter_SetTrimSurfaceData, METH_VARARGS,
   "V.SetTrimSurfaceData(vtkPolyData)\nC++: void SetTrimSurfaceData(vtkPolyData *pd)\n\nSpecify the surface which trims the surface.  Note that the\nmethod SetTrimSurfaceData does not connect the pipeline. The\nalgorithm will work on the input data as it is without updating\nthe producer of the data.  The method SetTrimSurfaceConnection\nconnects the pipeline.\n"},
  {"SetTrimSurfaceConnection", PyvtkTrimmedExtrusionFilter_SetTrimSurfaceConnection, METH_VARARGS,
   "V.SetTrimSurfaceConnection(vtkAlgorithmOutput)\nC++: void SetTrimSurfaceConnection(vtkAlgorithmOutput *algOutput)\n\nSpecify the surface which trims the surface.  Note that the\nmethod SetTrimSurfaceData does not connect the pipeline. The\nalgorithm will work on the input data as it is without updating\nthe producer of the data.  The method SetTrimSurfaceConnection\nconnects the pipeline.\n"},
  {"GetTrimSurface", PyvtkTrimmedExtrusionFilter_GetTrimSurface, METH_VARARGS,
   "V.GetTrimSurface() -> vtkPolyData\nC++: vtkPolyData *GetTrimSurface()\nV.GetTrimSurface(vtkInformationVector) -> vtkPolyData\nC++: vtkPolyData *GetTrimSurface(vtkInformationVector *sourceInfo)\n\nReturn a pointer to the enclosing surface.\n"},
  {"SetCapping", PyvtkTrimmedExtrusionFilter_SetCapping, METH_VARARGS,
   "V.SetCapping(int)\nC++: virtual void SetCapping(int _arg)\n\nTurn on/off the capping of the extruded skirt.\n"},
  {"GetCapping", PyvtkTrimmedExtrusionFilter_GetCapping, METH_VARARGS,
   "V.GetCapping() -> int\nC++: virtual int GetCapping()\n\nTurn on/off the capping of the extruded skirt.\n"},
  {"CappingOn", PyvtkTrimmedExtrusionFilter_CappingOn, METH_VARARGS,
   "V.CappingOn()\nC++: virtual void CappingOn()\n\nTurn on/off the capping of the extruded skirt.\n"},
  {"CappingOff", PyvtkTrimmedExtrusionFilter_CappingOff, METH_VARARGS,
   "V.CappingOff()\nC++: virtual void CappingOff()\n\nTurn on/off the capping of the extruded skirt.\n"},
  {"SetExtrusionStrategy", PyvtkTrimmedExtrusionFilter_SetExtrusionStrategy, METH_VARARGS,
   "V.SetExtrusionStrategy(int)\nC++: virtual void SetExtrusionStrategy(int _arg)\n\nSpecify a strategy for extrusion. If the strategy is set to\n\"BOUNDARY_EDGES\" then the boundary edges of the input polygons\nand triangle strips are swept. (A boundary edge is an edge used\nby only one 2D primitive, e.g., polygon or triangle.)\nAlternatively, all edges can be swept. (This is particularly\nuseful when only sinple disconnected polygons exist in the input\nand so boundary calculation can be avoided.) By default boundary\nedges are extruded.\n"},
  {"GetExtrusionStrategy", PyvtkTrimmedExtrusionFilter_GetExtrusionStrategy, METH_VARARGS,
   "V.GetExtrusionStrategy() -> int\nC++: virtual int GetExtrusionStrategy()\n\nSpecify a strategy for extrusion. If the strategy is set to\n\"BOUNDARY_EDGES\" then the boundary edges of the input polygons\nand triangle strips are swept. (A boundary edge is an edge used\nby only one 2D primitive, e.g., polygon or triangle.)\nAlternatively, all edges can be swept. (This is particularly\nuseful when only sinple disconnected polygons exist in the input\nand so boundary calculation can be avoided.) By default boundary\nedges are extruded.\n"},
  {"SetExtrusionStrategyToBoundaryEdges", PyvtkTrimmedExtrusionFilter_SetExtrusionStrategyToBoundaryEdges, METH_VARARGS,
   "V.SetExtrusionStrategyToBoundaryEdges()\nC++: void SetExtrusionStrategyToBoundaryEdges()\n\nSpecify a strategy for extrusion. If the strategy is set to\n\"BOUNDARY_EDGES\" then the boundary edges of the input polygons\nand triangle strips are swept. (A boundary edge is an edge used\nby only one 2D primitive, e.g., polygon or triangle.)\nAlternatively, all edges can be swept. (This is particularly\nuseful when only sinple disconnected polygons exist in the input\nand so boundary calculation can be avoided.) By default boundary\nedges are extruded.\n"},
  {"SetExtrusionStrategyToAllEdges", PyvtkTrimmedExtrusionFilter_SetExtrusionStrategyToAllEdges, METH_VARARGS,
   "V.SetExtrusionStrategyToAllEdges()\nC++: void SetExtrusionStrategyToAllEdges()\n\nSpecify a strategy for extrusion. If the strategy is set to\n\"BOUNDARY_EDGES\" then the boundary edges of the input polygons\nand triangle strips are swept. (A boundary edge is an edge used\nby only one 2D primitive, e.g., polygon or triangle.)\nAlternatively, all edges can be swept. (This is particularly\nuseful when only sinple disconnected polygons exist in the input\nand so boundary calculation can be avoided.) By default boundary\nedges are extruded.\n"},
  {"SetCappingStrategy", PyvtkTrimmedExtrusionFilter_SetCappingStrategy, METH_VARARGS,
   "V.SetCappingStrategy(int)\nC++: virtual void SetCappingStrategy(int _arg)\n\nSpecify a strategy for capping. By default the points of the cap\npolygons are located where the extrusion intersects the capping\nsurface. However, to preserve planarity, or to place the capping\nsurface at the average/minimum/maximum distance of extrusion,\ndifferent strategies can be used. By default the average distance\nis used.\n\nNote if none of the extrusion rays intersect the trim surface,\nthen capping is not performed, nor is an extrusion skirt sent to\nthe output. Also note that if the capping strategy is set to\nINTERSECTION, and one of the extrusion rays of the generating\nprimitive does not intersect the trim surface, then no output\nwill be generated for that primitive. However if any other\ncapping strategy is used, capping will succeed if at least one\nextrusion ray strikes the trim surface (although missed extrusion\nray intersections will not factor into the determination of final\ncap location).\n\nFinally, note that any capping strategy other than INTERSECTION\nmay produce more points than expected because the output\nprimitives may have to be \"split apart\" to satisy the capping\nconstraint.\n"},
  {"GetCappingStrategy", PyvtkTrimmedExtrusionFilter_GetCappingStrategy, METH_VARARGS,
   "V.GetCappingStrategy() -> int\nC++: virtual int GetCappingStrategy()\n\nSpecify a strategy for capping. By default the points of the cap\npolygons are located where the extrusion intersects the capping\nsurface. However, to preserve planarity, or to place the capping\nsurface at the average/minimum/maximum distance of extrusion,\ndifferent strategies can be used. By default the average distance\nis used.\n\nNote if none of the extrusion rays intersect the trim surface,\nthen capping is not performed, nor is an extrusion skirt sent to\nthe output. Also note that if the capping strategy is set to\nINTERSECTION, and one of the extrusion rays of the generating\nprimitive does not intersect the trim surface, then no output\nwill be generated for that primitive. However if any other\ncapping strategy is used, capping will succeed if at least one\nextrusion ray strikes the trim surface (although missed extrusion\nray intersections will not factor into the determination of final\ncap location).\n\nFinally, note that any capping strategy other than INTERSECTION\nmay produce more points than expected because the output\nprimitives may have to be \"split apart\" to satisy the capping\nconstraint.\n"},
  {"SetCappingStrategyToIntersection", PyvtkTrimmedExtrusionFilter_SetCappingStrategyToIntersection, METH_VARARGS,
   "V.SetCappingStrategyToIntersection()\nC++: void SetCappingStrategyToIntersection()\n\nSpecify a strategy for capping. By default the points of the cap\npolygons are located where the extrusion intersects the capping\nsurface. However, to preserve planarity, or to place the capping\nsurface at the average/minimum/maximum distance of extrusion,\ndifferent strategies can be used. By default the average distance\nis used.\n\nNote if none of the extrusion rays intersect the trim surface,\nthen capping is not performed, nor is an extrusion skirt sent to\nthe output. Also note that if the capping strategy is set to\nINTERSECTION, and one of the extrusion rays of the generating\nprimitive does not intersect the trim surface, then no output\nwill be generated for that primitive. However if any other\ncapping strategy is used, capping will succeed if at least one\nextrusion ray strikes the trim surface (although missed extrusion\nray intersections will not factor into the determination of final\ncap location).\n\nFinally, note that any capping strategy other than INTERSECTION\nmay produce more points than expected because the output\nprimitives may have to be \"split apart\" to satisy the capping\nconstraint.\n"},
  {"SetCappingStrategyToMinimumDistance", PyvtkTrimmedExtrusionFilter_SetCappingStrategyToMinimumDistance, METH_VARARGS,
   "V.SetCappingStrategyToMinimumDistance()\nC++: void SetCappingStrategyToMinimumDistance()\n\nSpecify a strategy for capping. By default the points of the cap\npolygons are located where the extrusion intersects the capping\nsurface. However, to preserve planarity, or to place the capping\nsurface at the average/minimum/maximum distance of extrusion,\ndifferent strategies can be used. By default the average distance\nis used.\n\nNote if none of the extrusion rays intersect the trim surface,\nthen capping is not performed, nor is an extrusion skirt sent to\nthe output. Also note that if the capping strategy is set to\nINTERSECTION, and one of the extrusion rays of the generating\nprimitive does not intersect the trim surface, then no output\nwill be generated for that primitive. However if any other\ncapping strategy is used, capping will succeed if at least one\nextrusion ray strikes the trim surface (although missed extrusion\nray intersections will not factor into the determination of final\ncap location).\n\nFinally, note that any capping strategy other than INTERSECTION\nmay produce more points than expected because the output\nprimitives may have to be \"split apart\" to satisy the capping\nconstraint.\n"},
  {"SetCappingStrategyToMaximumDistance", PyvtkTrimmedExtrusionFilter_SetCappingStrategyToMaximumDistance, METH_VARARGS,
   "V.SetCappingStrategyToMaximumDistance()\nC++: void SetCappingStrategyToMaximumDistance()\n\nSpecify a strategy for capping. By default the points of the cap\npolygons are located where the extrusion intersects the capping\nsurface. However, to preserve planarity, or to place the capping\nsurface at the average/minimum/maximum distance of extrusion,\ndifferent strategies can be used. By default the average distance\nis used.\n\nNote if none of the extrusion rays intersect the trim surface,\nthen capping is not performed, nor is an extrusion skirt sent to\nthe output. Also note that if the capping strategy is set to\nINTERSECTION, and one of the extrusion rays of the generating\nprimitive does not intersect the trim surface, then no output\nwill be generated for that primitive. However if any other\ncapping strategy is used, capping will succeed if at least one\nextrusion ray strikes the trim surface (although missed extrusion\nray intersections will not factor into the determination of final\ncap location).\n\nFinally, note that any capping strategy other than INTERSECTION\nmay produce more points than expected because the output\nprimitives may have to be \"split apart\" to satisy the capping\nconstraint.\n"},
  {"SetCappingStrategyToAverageDistance", PyvtkTrimmedExtrusionFilter_SetCappingStrategyToAverageDistance, METH_VARARGS,
   "V.SetCappingStrategyToAverageDistance()\nC++: void SetCappingStrategyToAverageDistance()\n\nSpecify a strategy for capping. By default the points of the cap\npolygons are located where the extrusion intersects the capping\nsurface. However, to preserve planarity, or to place the capping\nsurface at the average/minimum/maximum distance of extrusion,\ndifferent strategies can be used. By default the average distance\nis used.\n\nNote if none of the extrusion rays intersect the trim surface,\nthen capping is not performed, nor is an extrusion skirt sent to\nthe output. Also note that if the capping strategy is set to\nINTERSECTION, and one of the extrusion rays of the generating\nprimitive does not intersect the trim surface, then no output\nwill be generated for that primitive. However if any other\ncapping strategy is used, capping will succeed if at least one\nextrusion ray strikes the trim surface (although missed extrusion\nray intersections will not factor into the determination of final\ncap location).\n\nFinally, note that any capping strategy other than INTERSECTION\nmay produce more points than expected because the output\nprimitives may have to be \"split apart\" to satisy the capping\nconstraint.\n"},
  {"SetLocator", PyvtkTrimmedExtrusionFilter_SetLocator, METH_VARARGS,
   "V.SetLocator(vtkAbstractCellLocator)\nC++: void SetLocator(vtkAbstractCellLocator *locator)\n\nSpecify a cell locator. By default a vtkStaticCellLocator is\nused. The locator performs efficient searches to intersect cells.\n"},
  {"GetLocator", PyvtkTrimmedExtrusionFilter_GetLocator, METH_VARARGS,
   "V.GetLocator() -> vtkAbstractCellLocator\nC++: virtual vtkAbstractCellLocator *GetLocator()\n\nSpecify a cell locator. By default a vtkStaticCellLocator is\nused. The locator performs efficient searches to intersect cells.\n"},
  {nullptr, nullptr, 0, nullptr}
};

static PyTypeObject PyvtkTrimmedExtrusionFilter_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "vtkFiltersModelingPython.vtkTrimmedExtrusionFilter", // tp_name
  sizeof(PyVTKObject), // tp_basicsize
  0, // tp_itemsize
  PyVTKObject_Delete, // tp_dealloc
  nullptr, // tp_print
  nullptr, // tp_getattr
  nullptr, // tp_setattr
  nullptr, // tp_compare
  PyVTKObject_Repr, // tp_repr
  nullptr, // tp_as_number
  nullptr, // tp_as_sequence
  nullptr, // tp_as_mapping
  nullptr, // tp_hash
  nullptr, // tp_call
  PyVTKObject_String, // tp_str
  PyObject_GenericGetAttr, // tp_getattro
  PyObject_GenericSetAttr, // tp_setattro
  &PyVTKObject_AsBuffer, // tp_as_buffer
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC|Py_TPFLAGS_BASETYPE, // tp_flags
  PyvtkTrimmedExtrusionFilter_Doc, // tp_doc
  PyVTKObject_Traverse, // tp_traverse
  nullptr, // tp_clear
  nullptr, // tp_richcompare
  offsetof(PyVTKObject, vtk_weakreflist), // tp_weaklistoffset
  nullptr, // tp_iter
  nullptr, // tp_iternext
  nullptr, // tp_methods
  nullptr, // tp_members
  PyVTKObject_GetSet, // tp_getset
  nullptr, // tp_base
  nullptr, // tp_dict
  nullptr, // tp_descr_get
  nullptr, // tp_descr_set
  offsetof(PyVTKObject, vtk_dict), // tp_dictoffset
  nullptr, // tp_init
  nullptr, // tp_alloc
  PyVTKObject_New, // tp_new
  PyObject_GC_Del, // tp_free
  nullptr, // tp_is_gc
  nullptr, // tp_bases
  nullptr, // tp_mro
  nullptr, // tp_cache
  nullptr, // tp_subclasses
  nullptr, // tp_weaklist
  VTK_WRAP_PYTHON_SUPPRESS_UNINITIALIZED
};

static vtkObjectBase *PyvtkTrimmedExtrusionFilter_StaticNew()
{
  return vtkTrimmedExtrusionFilter::New();
}

PyObject *PyvtkTrimmedExtrusionFilter_ClassNew()
{
  PyVTKClass_Add(
    &PyvtkTrimmedExtrusionFilter_Type, PyvtkTrimmedExtrusionFilter_Methods,
    "vtkTrimmedExtrusionFilter",
 &PyvtkTrimmedExtrusionFilter_StaticNew);

  PyTypeObject *pytype = &PyvtkTrimmedExtrusionFilter_Type;

  if ((pytype->tp_flags & Py_TPFLAGS_READY) != 0)
  {
    return (PyObject *)pytype;
  }

#if !defined(VTK_PY3K) && PY_VERSION_HEX >= 0x02060000
  pytype->tp_flags |= Py_TPFLAGS_HAVE_NEWBUFFER;
#endif

  pytype->tp_base = (PyTypeObject *)PyvtkPolyDataAlgorithm_ClassNew();

  PyObject *d = pytype->tp_dict;
  PyObject *o;

  PyType_Ready(&PyvtkTrimmedExtrusionFilter_ExtrusionStrategy_Type);
  PyvtkTrimmedExtrusionFilter_ExtrusionStrategy_Type.tp_new = nullptr;
  vtkPythonUtil::AddEnumToMap(&PyvtkTrimmedExtrusionFilter_ExtrusionStrategy_Type);

  o = (PyObject *)&PyvtkTrimmedExtrusionFilter_ExtrusionStrategy_Type;
  if (PyDict_SetItemString(d, "ExtrusionStrategy", o) != 0)
  {
    Py_DECREF(o);
  }

  PyType_Ready(&PyvtkTrimmedExtrusionFilter_CappingStrategy_Type);
  PyvtkTrimmedExtrusionFilter_CappingStrategy_Type.tp_new = nullptr;
  vtkPythonUtil::AddEnumToMap(&PyvtkTrimmedExtrusionFilter_CappingStrategy_Type);

  o = (PyObject *)&PyvtkTrimmedExtrusionFilter_CappingStrategy_Type;
  if (PyDict_SetItemString(d, "CappingStrategy", o) != 0)
  {
    Py_DECREF(o);
  }

  for (int c = 0; c < 2; c++)
  {
    static const struct { const char *name; int value; }
      constants[2] = {
        { "BOUNDARY_EDGES", vtkTrimmedExtrusionFilter::BOUNDARY_EDGES },
        { "ALL_EDGES", vtkTrimmedExtrusionFilter::ALL_EDGES },
      };

    o = PyvtkTrimmedExtrusionFilter_ExtrusionStrategy_FromEnum(constants[c].value);
    if (o)
    {
      PyDict_SetItemString(d, constants[c].name, o);
      Py_DECREF(o);
    }
  }

  for (int c = 0; c < 4; c++)
  {
    static const struct { const char *name; int value; }
      constants[4] = {
        { "INTERSECTION", vtkTrimmedExtrusionFilter::INTERSECTION },
        { "MINIMUM_DISTANCE", vtkTrimmedExtrusionFilter::MINIMUM_DISTANCE },
        { "MAXIMUM_DISTANCE", vtkTrimmedExtrusionFilter::MAXIMUM_DISTANCE },
        { "AVERAGE_DISTANCE", vtkTrimmedExtrusionFilter::AVERAGE_DISTANCE },
      };

    o = PyvtkTrimmedExtrusionFilter_CappingStrategy_FromEnum(constants[c].value);
    if (o)
    {
      PyDict_SetItemString(d, constants[c].name, o);
      Py_DECREF(o);
    }
  }

  PyType_Ready(pytype);
  return (PyObject *)pytype;
}

void PyVTKAddFile_vtkTrimmedExtrusionFilter(
  PyObject *dict)
{
  PyObject *o;
  o = PyvtkTrimmedExtrusionFilter_ClassNew();

  if (o && PyDict_SetItemString(dict, "vtkTrimmedExtrusionFilter", o) != 0)
  {
    Py_DECREF(o);
  }

}

